/*
  Test result:
  
  CASE 1:
  ~/High_Accuracy_Float_Calculator$ ./a.out 
  Please input the operation that you want(+, -, * or /): -
  Please input the two operands, parting them by enter:
  The first operand:
  75893427.347819
  The second operand:
  12341.3434566611
  Calculation results:
  75881086.00436233890
  
  CASE 2:
  ~/High_Accuracy_Float_Calculator$ ./a.out 
  Please input the operation that you want(+, -, * or /): -
  Please input the two operands, parting them by enter:
  The first operand:
  47325848957398457823945729384579328457983457324895719873741987491873598347593485732984572394857823945732498572349
  85732495873459834759324857349857349857324985734985732485932475982375893275983247532984573249857349857918739418579
  45719348157935719345719348571935739457913471589745934759375982348758392481457983147524752394573498573495739417573
  914571935719351345.4289357293457289357471958723498573495873249573249572349583247593248573249573495347593475349573
  495723495732459324758932457324895734957348953475934257349573495347534958798
  The second operand:
  47589234759245729345782394572394857234895734953724952734592374592347592345723945734957324895732495734957324957324
  59324758329457234957348957345932475938245732495732495734532495734957324857349572345983247593457349857349537459348
  57349587324895723495723495324875329485734953728459324753924573945273495723459234852345789234587234532475234957239
  453495234.4579238475923485723495723495723495723495732459324857392457324957324859234875
  Calculation results:
  4732584890980922306470000003879693388558860008999998492001703475728122375524589338726062665990049905000000283739253236763414135076429867622392508392511392509796739999990199980247843397541025922675635000903874102264461389561229919734133005  86132020823625076212244133038142104010981030916657594833818536184487424065517542227709338908504885098679614696265856110  .9710118817533803633976235227775077772377517113924714957125922635923714014698495347593475349573495723495732459324758932  4573248957349573489534759342573495734953475349587980

  CASE 3:
  ~/High_Accuracy_Float_Calculator$ ./a.out 
  Please input the operation that you want(+, -, * or /): +
  Please input the two operands, parting them by enter:
  The first operand:
  458293.489327489     
  The second operand:
  2141.543599911
  Calculation results:
  460435.0329274000

  CASE 4:
  ~/High_Accuracy_Float_Calculator$ ./a.out 
  Please input the operation that you want(+, -, * or /): +
  Please input the two operands, parting them by enter:
  The first operand:
  45789234759324752398457293455555555555555555555555555555555555555555555555555555555555555555555555555555555555555
  555555555555555777777777777777777745928345732945792343452235151.4357283475892345793485793245732945234592359237598
  34572395723957324957324594759234572394572394572395723849573249544444444444444444444444444444444444444444444444444
  44444444444444444444444444523485923475923457239458723495723945739457324532452345234532455435325324534523
  The second operand:
  34758924759234572394572394572394572394572394579457329457293415791357915137534871503510347150345178309570943571390
  47539481563481347513471509236512957349710239847129037401238965018937423891471239804712394127349102347203471203471
  203471243710234712034123401273412034.4293784719234234923412034817203471234910234712390471234021934712034723047120
  34712034710237412034123410237471230472134071247213471230471230472130471230471234723147023847123084712347123089471
  23842134702134981237408921347213471283472138472318947231894721394712394072342103471230471230472139401234721304721
  347210347123479123471230947123472314972342318947123894721347123481923741239471239471239412
  Calculation results:
  34758924759234572394572394572394572394572394579457329457293415791357915137534871503510805042692771557094928144325030950  37119036903069027064792068512905265795402684592956794520574492979447026795360267949682904657902981248981248981248989638  580444979915744725647185.8651068195126580716897828062936416469502593949988816957979174285284296293067939466071048098066  06519134087044480016578515691657915674915674916574915674915679167591468291567529156791567533916473280581780584384768676  44842937417022929463004771292466427176830037718606865103471230471230472139401234721304721347210347123479123471230947123  4723149723423189471238947213471234819237412394712394712394120

  CASE 5:
  ~/High_Accuracy_Float_Calculator$ ./a.out 
  Please input the operation that you want(+, -, * or /): *
  Please input the two operands, parting them by enter:
  The first operand:
  4134.314
  The second operand:
  13421343.3499
  Calculation results:
  55488047710.2984686

  CASE 6:
  ~/High_Accuracy_Float_Calculator$ ./a.out                                                                        
  Please input the operation that you want(+, -, * or /): *                                                        
  Please input the two operands, parting them by enter:                                                            
  The first operand:                                                                                               
  45789234578392475938475928345793824579382475981375832495713498574758934753489573249573489573498573498573495834758
  93457348957349857348957349571938473513745134510345000000000000000000000000000000000000000000000000000000000000000
  00000004538927598324717593487593241575791347159711111111111111111111111598347593245739245732495734957348953475934
  85734957324958347593457324985734895734895347589347598435734985734985734985734985734985732489573295732495723953724
  59348759832457893475932487534957348957349573459234753928457234958374593475893457349257324957349573495347593457349
  57349573489573489573489573498573249573249511111111111111111111111111111111111111111111111111111111111111111111111
  11111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  0000000000000000000000.475893247592347593248578392457293457239457324958723495723495732495723495732495723495732495
  72349572394572957197581975195719345719347578139457139581345139457139457134951345871349571349573495731945734957329
  45734957349573495734913795734957319457831495731495713495731495731495713495713957349571395713957139571395713957139
  45739457349573495734593475913457193791554134051389501345813045813045813409583104581340598130458134059813045813409
  58314058314058134058134058314058314058134058134905348590134859013458103458130458310458130458134058130581340583140
  5813405813405813450134851045830458349015                                                                         
  The second operand:
  4579823471589375917859178591347519571934578193457314895718394571893571839457193457813495713495713495713495713495$
  1394571394571349573149571349571349571394571394571394571349573149571349573489571389571839571394571349571394571384$
  5713947519357139457183957139457139457139457134957349571349571394571394571394571394571395713945713495731495713957$
  3957134513451.48591348159038591034581304581340581340581304581934510349583140581304581340589130458130111111111111$
  1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111$
  1111111111100000000000000000000000000000000000000000000000000000000349538459023485048509348523457893245734957349$
  347593
  Calculation results:
  20970661126823372291054411256266482950845718468339981464607853106133385939429337334141946196095060177859105205053288365224633898357603748058387370489360931958600346538662644210152333832848764108899118990681389569006682781972725607409907  2686701357802023734326034386590383265026215442796072186840375413495261133388307479538043357348698273717199707114523276  2314501432443502972970377690495705226477633557136842450329831573199431366266516617065363899306839787431027399633930639  3826560785719298484400788516755438840656576339696398566129608442510021490421827380032447720901923502994163489233262571  1613108462556976500668569413892730432195406628833814117562164075909378824458736277762875463205138245326194615929410070  7736660899096353825580492043418832956174463848223647975034525125658934953389871012534669315029201601156183360706557598  9377237247272384402355573862405053825985295929433460139040471432517849725804996093621219153189645545203476962308477110  9011866410281897323597759270612468643836741301085683252535082449923763256466122837837696427879292397214025523270251490  6843246291188204553678399100377802406142418662098816050622410640633133142942499777397891381183186679535700177573240225  14121834580442911741997436571180633023186238508118168344319035311754022710906581732117379924149752.9125846036685602923  3303927847260284731484258669991016325186892641856336823694432799019022994176736245587263066669189143459569597719904302  3180754836425254639512800394567093671250774208893342688240509102346819614371785159039755729153180905043005401393225873  2934623972093061637313447399192231129105366434477848377525422233405809644706598845570192834289287190759541834122853439  7393559420830787574441257124540958116603554960682819710155945136437512712844774006222489020443492915212947519308083524  3228847920136751684285992020819242509811449034831289819593260344413310229756055304513732139706255638858098523939458170  4834705559428197083745401944866684752289391898546321029240441900164000606212093302674668232944061087011044403977940014  0435457669448469773497650244754890863597536528269270499078061871470066432274365047249791450312239991173197706088230248  99021596155037249356794119780670632382817909499261945449866334170895
 */



/*
  Every time, if you confused one function, say it's "fun", you can test it's effect by function 
  that begin with t, aka "t_fun"". The function end with _m show that is for multiplication 
  operation,  end with _d is for division operation.
*/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>


int dot_pos(char *in, int len);
int show_mul(int *res_m, char *in1, char *in2, int len1, int len2, int pos1, int pos2);

int test_data(char *in)//Test the data, the data only including number digit or dot. The input as
//string form.
{
  int i, len = strlen(in);

  for (i = 0; i <= len - 1; i++)
    {
      if ( !(0 <= (int)(in[i] - 48) && (int)(in[i] - 48) <= 9 ) && in[i] != '.')// If the in[i]
	// is not number digit and not dot, return 0.
	return 0;
    }

  return 1;
}

int res_dot(char *in1, char *in2, int len1, int len2)
//Decide the position of dot in add and sub computing result, notice this function is not for
//multiplication and division operation. The first argument is input1 as string form, the second
//argument is input2 as string form, the third argument is the length of the first argument, the last
//argument is the length of the second argument.
{
  if (dot_pos(in1, len1) >= dot_pos(in2, len2))
    return dot_pos(in1, len1);

  return dot_pos(in2, len2);
}


int res_len(int len1, int len2, int pos1, int pos2)// Return the length of result, this function is
//not for multiplication and division operation. We treat a number as two parts, one part is before
//dot, and the other is after dot. The length of add result should be the sum of lengths of this
//two parts that corresponding part longer comparing between two plus numbers, and add 1.
    
{
  int len;

  if (pos1 >= pos2)//For before dot, determine which is longer.
    len = pos1;
  else
    len = pos2;

  if ((len1 - pos1) >= (len2 - pos2))//For after dot, determine which is longer.
    len += len1 - pos1;
  else
    len += len2 - pos2;
  
  return len;// Return the sum of this two longer lengths as length of add result.
}


int store(char *in)// Store input as char string.
{
  scanf("%s", in);

  return 0;
}


int t_store(char *in)// Test for store function.
{
  puts(in);

  return 0;
}


int ctoi(char *in, int len_in, int *ini,  int pos, int res_pos)
// Convert char in string to int, and keep their form is uniform, the meaning of uniform is that
//they have same length and aligned dot after convert.
{
  int i, k;
  i = pos - 1;
  k = res_pos - 1;
  
  while (i >= 0)//First convert before dot part.
    {
      ini[k] = (int)(in[i] - 48);
      i--;
      k--;
    }

  i = pos + 1;
  k = res_pos;

  while (i <= len_in - 1)//Then convert after dot part.
    {
      ini[k] = (int)(in[i]-48);
      i++;
      k++;
    }
  
  return 0;
}


int t_ctoi(int *ini, int max_len)// Test for convert function

{
  int i;

  for (i = 0; i <= max_len - 1; i++)
    printf("%d", ini[i]);

  printf("\n");
  
  return 0;
}


int add(int *res, int *ini1, int *ini2, int max_len)
// Add two integer, they store in int array.
{
  int i, tmp, jw = 0, k = max_len;

  for (i = max_len - 1; i >= 0; i--)
    {
      tmp = ini1[i] + ini2[i];// Add the two number digits.
      res[k] = (jw + tmp) % 10;// The result digit should be modulus of sum of carry and two number
      //digits.
      jw = (tmp + jw) / 10;
      k--;
    }

  res[0] = jw;// Note that the carry can be reach the highest position.
  
  return 0;
}


int show_add(int *res, int len, int res_pos)// Show the computing result of addition.
{
  int i;

  if (res[0] != 0)// If no carry in the highest position, we don't need output this digit.
    printf("%d", res[0]);
  
  for (i = 1; i <= len - 1; i++)
    {
      if (i == res_pos + 1)// Because add maybe create carry bit,
	//so dot position different.
	printf(".");

      printf("%d", res[i]);
    }
    
  printf ("\n");

  return 0;
}


int show_sub(int *res, int len, int res_pos, int indi)//Show result of sub operation, the first
//argument is result, the second argument is length of string, the third argument is the dot
//position of sub result, and the last argument is a indicator to judge whether the result is
//a negative number.
{
  int i = 0, start;

  if (indi == 2)// First we need to know which number is larger so that we determine the output of
    //minus.
    printf("-");
  
  while (i <= len - 1 && i != res_pos)//Seek the first no zero position of sub result.
    {
      if (res[i] == 0)
	{
	  i++;
	  continue;
	}

      break;
    }

  start = i;// From the first no zero position output.

  if (start == res_pos)
    printf("0");
  
  for (; start <= len - 1; start++)
    {
      if (start == res_pos)// If the position equal to dot position of sub result.
	printf(".");// Print the dot.

      printf("%d", res[start]);
    }

  printf("\n");
  
  return 0;
}


int judge(int *ini1, int *ini2, int max_len)// Judge the size of this two number for sub operation.
{
  int i;

  for (i = 0; i <= max_len - 1; i++)
    {
      if (ini1[i] == ini2[i])
	continue;

      else if (ini1[i] > ini2[i])// The first argument larger than the second argument, return 1.
	return 1;

      else if (ini2[i] > ini1[i])// The second argument larger than the first argument ,return 2.
	return 2;
    }

  return 0;
}


int sub(int *res, int *ini1, int *ini2, int max_len, int indi)// Subtraction operation, the result
//of sub is store in first argument, the second argument is subtraction number and the third is be
//subtracted, the forth is max length of this two inputs, the last argument is an indicator that
//indict which one is larger(or smaller).
{
  int i, tmp, jw = 0;
  
  if (indi == 1)// By indicator we always use the larger number sub to smaller.
    {
      for (i = max_len - 1; i >= 0; i--)
	{
	  if ((ini1[i] - jw ) < ini2[i])// First minus borrow bit, then compare.
	    {
	      tmp = ini1[i] - jw + 10;// If we need to borrow, we need add ten.
	      res[i] = tmp - ini2[i];
	      jw = 1;
	    }

	  else// Don't borrow.
	    {
	      tmp = ini1[i] - jw;
	      res[i] = tmp - ini2[i];
	      jw = 0;
	    }
	}
    }

  if (indi == 2)
    {
      for (i = max_len - 1; i >= 0; i--)
	{
	  if ((ini2[i] - jw ) < ini1[i])// First minus borrow bit, then compare.
	    {
	      tmp = ini2[i] - jw + 10;
	      res[i] = tmp - ini1[i];
	      jw = 1;
	    }

	  else
	    {
	      tmp = ini2[i] - jw;
	      res[i] = tmp - ini1[i];
	      jw = 0;
	    }
	}
    }
  
  return 0;
}


int mul_sin(int *res_sin, int *ini_m, int width_m,  int mulor)// Multiplication for form such as ,
//4 * 34123, aka only one digit multiply a number, the result is store in the first argument. The
//"normal" number is the second argument, the last number is single digit, 4 example here. And the
//third argument is the length of the second argument. This function is prepare for multiplication
//operation.
{
  int i, k = width_m, jw = 0, tmp;

  for (i = width_m - 1; i >= 0; i--)
    {
      tmp = mulor * ini_m[i] + jw;// Add as temporary value.
      res_sin[k] = tmp % 10;// The result digit should be modules.
      jw = tmp / 10;// Computing carry.
      k--;// Start multiplication with the last digit of second argument, so k--.
    }

  res_sin[0] = jw;// Note that the carry maybe go to the highest digit.

  return 0;
}


int dot_judge(char *in, int len)// Judge the input existing of dot in input.
{
  int i;

  for (i = 0; i <= len - 1; i++)
    {
      if (in[i] == '.')
	return 1;
    }

  return 0;
}


int t_mul_sin(int *res_sin, int width_m)// Test function.
{
  int i;

  if (res_sin[0] != 0)
    printf("%d", res_sin[0]);
  
  for (i = 1; i <= width_m; i++)
    printf("%d", res_sin[i]);
  
  printf("\n");

  return 0;
}

int dot_pos(char *in, int len)// Return the dot position of input string.
{
  int i;

  for (i = 0; i <= len - 1; i++)
    {
      if (in[i] == '.')
	return i;
    }

  return len;
}


int ctoi_m(char *in, int len, int *res_m)// Converting function for multiplication.
{
  int i, k = 0;

  for (i = 0; i <= len - 1; i++)
    {
      if (in[i] != '.')
	{
	  res_m[k] = (int)(in[i] - 48);
	  k++;
	}
    }

  return 0;
}


int t_ctoi_m(int *ini_m, int width_m)// Test function.
{
  int i;
  
  for (i = 0; i <= width_m - 1; i++)
    printf("%d", ini_m[i]);

  printf("\n");
  return 0;
}


int width_m(char *in, int len)// Return the length of input for multiplication operation, sub to
// 1 if there is a dot in input.
{
  int width_m;
  if (dot_judge(in, len))
    width_m = len - 1;
  else
    width_m = len;

  return width_m;
}


int init_tmp(int *tmp_m, int len)// This function is not use.
{
  int i = 0;

  for (i = 0;i <= len - 1; i++)
    tmp_m[i] = 0;

  return 0;
}


int add_m(int *res_m, int *tmp_m, int width_tmp, int offset)// Add for multiplication, the result
//is store in the first argument, and the second argument was added. the third argument is the
//length of the added number, the last number is offset, for example, add 43553354 and 3452355, 
//4355335|4               435533|54                43553|354
//       |  offset is 1,        |   offset is 2,        |    offset is 3.
//3452355|               3452355|                3452355|
{
  int i = 999998 - offset, tmp, jw = 0;
  int j = width_tmp - 1;

  while (j >= 0)
    {
      tmp = tmp_m[j] + res_m[i];
      res_m[i] = (jw + tmp) % 10;
      jw = (tmp + jw) / 10;
      i--;
      j--;
    }

  while (i >= 0)
    {
      tmp = res_m[i];
      res_m[i] = (jw + tmp) % 10;
      jw = (tmp + jw) / 10;
      i--;
    }

  return 0;
}


int mul(int *ini_m1, int *ini_m2, int *res_m, int width_m1, int width_m2)// The multiplication
//operation, the first and second argument are inputs, and result of multiplied is stored in the
//third argument, and the forth argument is the length of the first argument, the last argument is
//the length of the second argument.
{
  int i, offset = 0;
  int *tmp_m = (int*)malloc((width_m1 + 1) * sizeof(int));// This variable is store temporary
  //multiplied result.

  for (i = width_m2 - 1; i >= 0; i--)
    {
      mul_sin(tmp_m, ini_m1, width_m1, ini_m2[i]);//For each element in the second argument,
      //multiply the the first argument.

      add_m(res_m, tmp_m, width_m1 + 1, offset);// Add the temporary result.

      init_tmp(tmp_m, width_m1 + 1);
      
      offset++;//The add in multiplication is offset.
    }
  
  return 0;
}


int find(int *res_m, int dot_pos)// Find the first no zero element in multiplication result until
//dot position, the first argument is result, and the second is the position of dot in result.
{
  int i = 0;

  for (i = 0; i <= dot_pos - 1; i++)
    {
      if (res_m[i] != 0)
	return i;
    }

  return i;
}


int dot_mul(char *in1, char *in2, int len1, int len2, int pos1, int pos2)// Identify the dot
//position of multiplication result.
{ 
  int dot_left = (len1 - pos1 - 1 + len2 - pos2 - 1);

  return 999998 - dot_left;
}


int show_mul1(int *res_m, char *in1, char *in2, int len1, int len2, int pos1, int pos2)// Show the
//result of multiplication result. The first argument is result, the second argument is input1 as
//string form, and the third argument is input2 as string form, the forth argument is the length of
//the second argument, the fifth argument is the length of the third argument, the sixth argument is
//the dot position of the second argument, and the last argument is the dot position of the third
//argument.
{
  int dot_pos = dot_mul(in1, in2, len1, len2, pos1, pos2);// Identify the dot position of result.
  int no_z = find(res_m, dot_pos);// Find the first no zero element in result.
  int i;

  for (i = no_z; i <= dot_pos; i++)// Output before dot position part.
    printf("%d", res_m[i]);

  printf(".");// Print dot.

  for (i = (dot_pos + 1); i <= 999998; i++)// Output after dot position part.
    printf("%d", res_m[i]);
      
  printf("\n");

  return 0;
}


int add_dot_m(char *in1, char *in2)// If the input no dot, add it at length. The two arguments are
//inputs as string form.
{
  int len1 = strlen(in1);
  int len2 = strlen(in2);
  
  if (!dot_judge(in1, len1))
    in1[len1] = '.';

  if (!dot_judge(in2, len2))
    in2[len2] = '.';

  return 1;
}


int main(int argc, char *argv[])
{
  char in1[999999], in2[999999], op;// in1 and in2 are inputs as string form, op is operation such
  //as +, -, *, /.
  int *res_m = (int*)malloc(999999 * sizeof(int));

  printf("Please input the operation that you want(+, -, * or /): ");
  scanf("%c", &op);

  printf("Please input the two operands, parting them by enter:\n");

  printf("The first operand:\n");
  store(in1);
  printf("The second operand:\n");
  store(in2);

  if (op == '*')
    add_dot_m(in1, in2);//If the user want multiplication, first add dot at end if the input no dot.

  int len1 = strlen(in1);
  int pos1 = dot_pos(in1, len1);

  int len2 = strlen(in2);
  int pos2 = dot_pos(in2, len2);

  int  max_len = res_len(len1, len2, pos1, pos2);

  int *ini1 = (int*)malloc(max_len * sizeof(int));
  int *ini2 = (int*)malloc(max_len * sizeof(int));

  int *res = (int*)malloc(max_len * sizeof(int));
  int res_pos = res_dot(in1, in2, len1, len2);
  
  int width_m1 = width_m(in1, len1), width_m2 = width_m(in2, len2);
    
  int *ini_m1 = (int*)malloc(width_m1 * sizeof(int));
  int *ini_m2 = (int*)malloc(width_m2 * sizeof(int));

  ctoi(in1, len1, ini1, pos1, res_pos);
  
  ctoi(in2, len2, ini2, pos2, res_pos);

  ctoi_m(in1, strlen(in1), ini_m1);
  
  ctoi_m(in2, strlen(in2), ini_m2);
  
  if (!(test_data(in1) && test_data(in2)))
    printf("Your data is wrong.\n");

  else
    {
      if (op == '*')
		  {

			  mul(ini_m1, ini_m2, res_m, width_m1, width_m2);
			  printf("Calculation results:\n");
	  show_mul1(res_m, in1, in2, len1, len2, pos1, pos2);
	}

      else if (op == '+')
	{
		add(res, ini1, ini2, max_len);
		printf("Calculation results:\n");
	  show_add(res, max_len + 1, res_pos);
	}

      else if (op == '-')
	{
	  int indi = judge(ini1, ini2, max_len);
	  if (indi == 0)
	    printf("0\n");
      
	  else
	    {
			sub(res, ini1, ini2, max_len, indi);
			printf("Calculation results:\n");
	      show_sub(res, max_len, res_pos, indi);
	    }
	}

      else if (op == '/')
	{
	  
	}

      else
	printf("Your operation is not permitted.\n");
    }
  
  return 0;
}
